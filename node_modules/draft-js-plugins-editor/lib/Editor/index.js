'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _draftJs = require('draft-js');

var _createCompositeDecorator = require('../utils/createCompositeDecorator');

var _createCompositeDecorator2 = _interopRequireDefault(_createCompositeDecorator);

var _moveSelectionToEnd = require('../utils/moveSelectionToEnd');

var _moveSelectionToEnd2 = _interopRequireDefault(_moveSelectionToEnd);

var _moveToEndOfSelectedBlock = require('../modifiers/moveToEndOfSelectedBlock');

var _moveToEndOfSelectedBlock2 = _interopRequireDefault(_moveToEndOfSelectedBlock);

var _moveToStartOfSelectedBlock = require('../modifiers/moveToStartOfSelectedBlock');

var _moveToStartOfSelectedBlock2 = _interopRequireDefault(_moveToStartOfSelectedBlock);

var _immutable = require('immutable');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * The main editor c;omponent
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var PluginEditor = function (_Component) {
  _inherits(PluginEditor, _Component);

  // TODO add flow types & propTypes - since it's a library and people might not use flow we want to have both

  function PluginEditor(props) {
    _classCallCheck(this, PluginEditor);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PluginEditor).call(this, props));

    _initialiseProps.call(_this);

    _this.plugins = (0, _immutable.List)(props.plugins).filter(function (plugin) {
      return plugin.pluginProps !== undefined;
    }).map(function (plugin) {
      return plugin.pluginProps;
    }).toArray();
    var compositeDecorator = (0, _createCompositeDecorator2.default)(_this.plugins, _this.getEditorState, _this.onChange);

    // TODO consider triggering an onChange here to make sure the editorState is in sync
    // with the outer Editor context
    var editorState = _draftJs.EditorState.set(_this.props.editorState, { decorator: compositeDecorator });
    _this.editorState = (0, _moveSelectionToEnd2.default)(editorState);
    return _this;
  }

  _createClass(PluginEditor, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      // Makes sure the editorState of the wrapping component is in sync with the
      // internal one, because we added the decorator in the constructor.
      if (this.props.onChange) {
        this.props.onChange(this.editorState);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.editorState = props.editorState;
    }

    // Cycle through the plugins, changing the editor state with what the plugins
    // changed (or didn't)


    // Put the keyboard focus on the editor

  }, {
    key: 'render',
    value: function render() {
      var pluginProps = {};
      this.plugins.forEach(function (plugin) {
        if (plugin.getEditorProps) {
          pluginProps = _extends({}, pluginProps, plugin.getEditorProps());
        }
      });

      return _react2.default.createElement(_draftJs.Editor, _extends({}, pluginProps, this.props, {
        onChange: this.onChange,
        editorState: this.editorState,
        blockRendererFn: this.blockRendererFn,
        handleKeyCommand: this.handleKeyCommand,
        keyBindingFn: this.keyBindingFn,
        onDownArrow: this.onDownArrow,
        onTab: this.onTab,
        onUpArrow: this.onUpArrow,
        onEscape: this.onEscape,
        handleReturn: this.handleReturn,
        ref: 'editor'
      }));
    }
  }]);

  return PluginEditor;
}(_react.Component);

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.onChange = function (editorState) {
    var newEditorState = editorState;
    _this2.plugins.forEach(function (plugin) {
      if (plugin.onChange) {
        newEditorState = plugin.onChange(newEditorState);
      }
    });

    if (_this2.props.onChange) {
      _this2.props.onChange(newEditorState);
    }
  };

  this.onDownArrow = function (keyboardEvent) {
    // TODO allow to provide a custom onDownArrow

    _this2.plugins.map(function (plugin) {
      if (plugin.onDownArrow) {
        plugin.onDownArrow(keyboardEvent);
      }

      return undefined;
    });
  };

  this.onUpArrow = function (keyboardEvent) {
    // TODO allow to provide a custom onUpArrow

    _this2.plugins.map(function (plugin) {
      if (plugin.onUpArrow) {
        plugin.onUpArrow(keyboardEvent);
      }

      return undefined;
    });
  };

  this.onEscape = function (keyboardEvent) {
    // TODO allow to provide a custom onEscape

    _this2.plugins.map(function (plugin) {
      if (plugin.onEscape) {
        plugin.onEscape(keyboardEvent);
      }

      return undefined;
    });
  };

  this.onTab = function (keyboardEvent) {
    // TODO allow to provide a custom onTab

    _this2.plugins.map(function (plugin) {
      if (plugin.onTab) {
        plugin.onTab(keyboardEvent);
      }

      return undefined;
    });
  };

  this.getEditorState = function () {
    return _this2.editorState;
  };

  this.handleKeyCommand = function (command) {
    var preventDefaultBehaviour = false;
    if (_this2.props.handleKeyCommand) {
      var handled = _this2.props.handleKeyCommand(command);
      if (handled === true) {
        preventDefaultBehaviour = true;
      }
    }

    // TODO optimize to break after the first one
    preventDefaultBehaviour = _this2.plugins.map(function (plugin) {
      if (plugin.handleKeyCommand) {
        var _handled = plugin.handleKeyCommand(command);
        if (_handled === true) {
          return _handled;
        }
      }

      return undefined;
    }).find(function (result) {
      return result === true;
    });

    if (command === 'plugin-editor-move-to-start') {
      (0, _moveToStartOfSelectedBlock2.default)(_this2.editorState, _this2.props.onChange);
      preventDefaultBehaviour = true;
    } else if (command === 'plugin-editor-move-to-end') {
      (0, _moveToEndOfSelectedBlock2.default)(_this2.editorState, _this2.props.onChange);
      preventDefaultBehaviour = true;
    }

    return preventDefaultBehaviour === true;
  };

  this.handleReturn = function (keyboardEvent) {
    // TODO optimize to break after the first one
    var preventDefaultBehaviour = _this2.plugins.map(function (plugin) {
      if (plugin.handleReturn) {
        var handled = plugin.handleReturn(keyboardEvent);
        if (handled === true) {
          return handled;
        }
      }

      return undefined;
    }).find(function (result) {
      return result === true;
    });

    // TODO allow to provide a custom handleReturn
    return preventDefaultBehaviour === true;
  };

  this.keyBindingFn = function (keyboardEvent) {
    // TODO optimize to break after the first one
    var command = _this2.plugins.map(function (plugin) {
      if (plugin.keyBindingFn) {
        var pluginCommand = plugin.keyBindingFn(keyboardEvent);
        if (pluginCommand) {
          return pluginCommand;
        }
      }

      return undefined;
    }).find(function (result) {
      return result !== undefined;
    });

    if (command === undefined) {
      if (keyboardEvent.keyCode === 37 && _draftJs.KeyBindingUtil.hasCommandModifier(keyboardEvent)) {
        command = 'plugin-editor-move-to-start';
      } else if (keyboardEvent.keyCode === 39 && _draftJs.KeyBindingUtil.hasCommandModifier(keyboardEvent)) {
        command = 'plugin-editor-move-to-end';
      }
    }

    // TODO allow to provide a custom handleKeyCommand

    return command !== undefined ? command : (0, _draftJs.getDefaultKeyBinding)(keyboardEvent);
  };

  this.blockRendererFn = function (contentBlock) {
    // TODO optimize to break after the first one
    if (_this2.props.blockRendererFn) {
      var result = _this2.props.blockRendererFn(contentBlock);
      if (result) {
        return result;
      }
    }

    return _this2.plugins.map(function (plugin) {
      if (plugin.blockRendererFn) {
        var _result = plugin.blockRendererFn(contentBlock, _this2.getEditorState, _this2.onChange);
        if (_result) {
          return _result;
        }
      }

      return undefined;
    }).find(function (result) {
      return result !== undefined;
    });
  };

  this.focus = function () {
    _this2.refs.editor.focus();
  };
};

exports.default = PluginEditor;